
Using FS and GS prefixes on 64bit x86 linux

The x86 architecture supports segment prefixes per instruction to add an
offset to an address.  On 64bit x86, these are mostly nops, except for FS
and GS.

This offers an efficient way to reference a global pointer.

The compiler has to generate special code to use these base registers,
or they can be accessed with inline assembler.

	mov %gs:offset,%reg
	mov %fs:offset,%reg

On 64bit code, FS is used to address the thread local segment (TLS), declared using
__thread.  The compiler then automatically generates the correct prefixes and
relocations to access these values.

FS is normally managed by the runtime code or the threading library
Overwriting it can break a lot of things (including syscalls and gdb),
but it can make sense to save/restore it for threading purposes.

GS is freely available, but may need special (compiler or inline assembler)
code to use.

Traditionally 64bit FS and GS could be set by the arch_prctl system call

	arch_prctl(ARCH_SET_GS, value)
	arch_prctl(ARCH_SET_FS, value)

[There was also an older method using modify_ldt(), inherited from 32bit,
but this is not discussed here.]

However using a syscall is problematic for user space threading libraries
that want to context switch in user space. The whole point of them
is avoiding the overhead of a syscall. It's also cleaner for compilers
wanting to use the extra register to use instructions to write
it, or read it directly to compute addresses and offsets.

Newer Intel CPUs (Ivy Bridge and later) added new instructions to directly
access these registers quickly from user context

	RDFSBASE %reg	read the FS base	(or _readfsbase_u64)
	RDGSBASE %reg	read the GS base	(or _readgsbase_u64)

	WRFSBASE %reg	write the FS base	(or _writefsbase_u64)
	WRGSBASE %reg	write the GS base	(or _writegsbase_u64)

If you use the intrinsics include <immintrin.h> and set the -mfsgsbase option.

The instructions are supported by the CPU when the "fsgsbase" string is shown in
/proc/cpuinfo (or directly retrieved through the CPUID instruction,
7:0 (ebx), word 9, bit 0)

The instructions are only available to 64bit binaries.

In addition the kernel needs to explicitly enable these instructions, as it
may otherwise not correctly context switch the state. Newer Linux
kernels enable this. When the kernel did not enable the instruction
they will fault with an #UD exception.

An FSGSBASE enabled kernel can be detected by checking the AT_HWCAP2
bitmask in the aux vector. When the HWCAP2_FSGSBASE bit is set the
kernel supports FSGSBASE.

	#include <sys/auxv.h>
	#include <elf.h>

	/* Will be eventually in asm/hwcap.h */
	#define HWCAP2_FSGSBASE        (1 << 1)

        unsigned val = getauxval(AT_HWCAP2);
        if (val & HWCAP2_FSGSBASE) {
                asm("wrgsbase %0" :: "r" (ptr));
        }

No extra CPUID check needed as the kernel will not set this bit if the CPU
does not support it.

gcc 6 will have special support to directly access data relative
to fs/gs using the __seg_fs and __seg_gs address space pointer
modifiers.

#ifndef __SEG_GS
#error "Need gcc 6 or later"
#endif

struct gsdata {
	int a;
	int b;
} gsdata = { 1, 2 };

int __seg_gs *valp = 0;		/* offset relative to GS */

	/* Check if kernel supports FSGSBASE as above */

	/* Set up new GS */
	asm("wrgsbase %0" :: "r" (&gsdata));

	/* Now the global pointer can be used normally */
	printf("gsdata.a = %d\n", *valp);

Andi Kleen
