* Power State Coordination Interface (PSCI)

Firmware implementing the PSCI functions described in ARM document number
ARM DEN 0022A ("Power State Coordination Interface System Software on ARM
processors") can be used by Linux to initiate various CPU-centric power
operations.

Issue A of the specification describes functions for CPU suspend, hotplug
and migration of secure software.

Functions are invoked by trapping to the privilege level of the PSCI
firmware (specified as part of the binding below) and passing arguments
in a manner similar to that specified by AAPCS:

	 r0		=> 32-bit Function ID / return value
	{r1 - r3}	=> Parameters

Note that the immediate field of the trapping instruction must be set
to #0.


Main node required properties:

 - compatible    : should contain at least one of:

     * "arm,psci"     : For implementations complying to PSCI versions prior
			to 0.2.
			For these cases function IDs must be provided.

     * "arm,psci-0.2" : For implementations complying to PSCI 0.2.
			Function IDs are not required and should be ignored by
			an OS with PSCI 0.2 support, but are permitted to be
			present for compatibility with existing software when
			"arm,psci" is later in the compatible list.

     * "arm,psci-1.0" : For implementations complying to PSCI 1.0.
			PSCI 1.0 is backward compatible with PSCI 0.2 with
			minor specification updates, as defined in the PSCI
			specification[2].

 - method        : The method of calling the PSCI firmware. Permitted
                   values are:

                   "smc" : SMC #0, with the register assignments specified
		           in this binding.

                   "hvc" : HVC #0, with the register assignments specified
		           in this binding.

Main node optional properties:

 - cpu_suspend   : Function ID for CPU_SUSPEND operation

 - cpu_off       : Function ID for CPU_OFF operation

 - cpu_on        : Function ID for CPU_ON operation

 - migrate       : Function ID for MIGRATE operation

Device tree nodes that require usage of PSCI CPU_SUSPEND function (ie idle
state nodes, as per bindings in [1]) must specify the following properties:

- arm,psci-suspend-param
		Usage: Required for state nodes[1] if the corresponding
                       idle-states node entry-method property is set
                       to "psci".
		Value type: <u32>
		Definition: power_state parameter to pass to the PSCI
			    suspend call.

Example:

Case 1: PSCI v0.1 only.

	psci {
		compatible	= "arm,psci";
		method		= "smc";
		cpu_suspend	= <0x95c10000>;
		cpu_off		= <0x95c10001>;
		cpu_on		= <0x95c10002>;
		migrate		= <0x95c10003>;
	};

Case 2: PSCI v0.2 only

	psci {
		compatible	= "arm,psci-0.2";
		method		= "smc";
	};

Case 3: PSCI v0.2 and PSCI v0.1.

	A DTB may provide IDs for use by kernels without PSCI 0.2 support,
	enabling firmware and hypervisors to support existing and new kernels.
	These IDs will be ignored by kernels with PSCI 0.2 support, which will
	use the standard PSCI 0.2 IDs exclusively.

	psci {
		compatible = "arm,psci-0.2", "arm,psci";
		method = "hvc";

		cpu_on = < arbitrary value >;
		cpu_off = < arbitrary value >;

		...
	};

PSCI v1.0 onwards, supports OS-Initiated mode for powering off CPUs and CPU
clusters from the firmware. For such topologies the PSCI firmware driver acts
as pseudo-controller, which may be specified in the psci DT node. The
definitions of the CPU and the CPU cluster topology, must conform to the domain
idle state specification [3]. The domain idle states themselves, must be
compatible with the defined 'domain-idle-state' binding [1], and also need to
specify the arm,psci-suspend-param property for each idle state.

DT allows representing CPU and CPU cluster idle states in two different ways -

The flattened model as given in Example 1, lists CPU's idle states followed by
the domain idle state that the CPUs may choose. This is the general practice
followed in PSCI firmwares that support Platform Coordinated mode. Note that
the idle states are all compatible with "arm,idle-state".

Example 2 represents the hierarchical model of CPU and domain idle states.
CPUs define their domain provider in their DT node. The domain controls the
power to the CPU and possibly other h/w blocks that would be powered off when
the CPU is powered off. The CPU's idle states may therefore be considered as
the domain's idle states and have the compatible "arm,idle-state". Such domains
may be embedded within another domain that represents common h/w blocks between
these CPUs viz. the cluster. The idle states of the cluster would be
represented as the domain's idle states. In order to use OS-Initiated mode of
PSCI in the firmware, the hierarchical representation must be used.

Example 1: Flattened representation of CPU and domain idle states
	cpus {
		#address-cells = <1>;
		#size-cells = <0>;

		CPU0: cpu@0 {
			device_type = "cpu";
			compatible = "arm,cortex-a53", "arm,armv8";
			reg = <0x0>;
			enable-method = "psci";
			cpu-idle-states = <&CPU_PWRDN>, <&CLUSTER_RET>,
					  <&CLUSTER_PWRDN>;
		};

		CPU1: cpu@1 {
			device_type = "cpu";
			compatible = "arm,cortex-a57", "arm,armv8";
			reg = <0x100>;
			enable-method = "psci";
			cpu-idle-states = <&CPU_PWRDN>, <&CLUSTER_RET>,
					  <&CLUSTER_PWRDN>;
		};

		idle-states {
			CPU_PWRDN: cpu-power-down {
				compatible = "arm,idle-state";
				arm,psci-suspend-param = <0x000001>;
				entry-latency-us = <10>;
				exit-latency-us = <10>;
				min-residency-us = <100>;
			};

			CLUSTER_RET: cluster-retention {
				compatible = "arm,idle-state";
				arm,psci-suspend-param = <0x1000010>;
				entry-latency-us = <500>;
				exit-latency-us = <500>;
				min-residency-us = <2000>;
			};

			CLUSTER_PWRDN: cluster-power-down {
				compatible = "arm,idle-state";
				arm,psci-suspend-param = <0x1000030>;
				entry-latency-us = <2000>;
				exit-latency-us = <2000>;
				min-residency-us = <6000>;
			};
	};

	psci {
		compatible = "arm,psci-0.2";
		method = "smc";
	};

Example 2: Hierarchical representation of CPU and domain idle states

	cpus {
		#address-cells = <1>;
		#size-cells = <0>;

		CPU0: cpu@0 {
			device_type = "cpu";
			compatible = "arm,cortex-a53", "arm,armv8";
			reg = <0x0>;
			enable-method = "psci";
			power-domains = <&CPU_PD0>;
		};

		CPU1: cpu@1 {
			device_type = "cpu";
			compatible = "arm,cortex-a57", "arm,armv8";
			reg = <0x100>;
			enable-method = "psci";
			power-domains = <&CPU_PD1>;
		};

		idle-states {
			CPU_PWRDN: cpu-power-down {
				compatible = "arm,idle-state";
				arm,psci-suspend-param = <0x000001>;
				entry-latency-us = <10>;
				exit-latency-us = <10>;
				min-residency-us = <100>;
			};

			CLUSTER_RET: cluster-retention {
				compatible = "domain-idle-state";
				arm,psci-suspend-param = <0x1000010>;
				entry-latency-us = <500>;
				exit-latency-us = <500>;
				min-residency-us = <2000>;
			};

			CLUSTER_PWRDN: cluster-power-down {
				compatible = "domain-idle-state";
				arm,psci-suspend-param = <0x1000030>;
				entry-latency-us = <2000>;
				exit-latency-us = <2000>;
				min-residency-us = <6000>;
			};
		};
	};

	psci {
		compatible = "arm,psci-1.0";
		method = "smc";

		CPU_PD0: cpu-pd0 {
			#power-domain-cells = <0>;
			domain-idle-states = <&CPU_PWRDN>;
			power-domains = <&CLUSTER_PD>;
		};

		CPU_PD1: cpu-pd1 {
			#power-domain-cells = <0>;
			domain-idle-states =  <&CPU_PWRDN>;
			power-domains = <&CLUSTER_PD>;
		};

		CLUSTER_PD: cluster-pd {
			#power-domain-cells = <0>;
			domain-idle-states = <&CLUSTER_RET>, <&CLUSTER_PWRDN>;
		};
	};

[1] Kernel documentation - ARM idle states bindings
    Documentation/devicetree/bindings/arm/idle-states.txt
[2] Power State Coordination Interface (PSCI) specification
    http://infocenter.arm.com/help/topic/com.arm.doc.den0022c/DEN0022C_Power_State_Coordination_Interface.pdf
[3]. PM Domains description
    Documentation/devicetree/bindings/power/power_domain.txt
