* Power State Coordination Interface (PSCI)

Firmware implementing the PSCI functions described in ARM document number
ARM DEN 0022A ("Power State Coordination Interface System Software on ARM
processors") can be used by Linux to initiate various CPU-centric power
operations.

Issue A of the specification describes functions for CPU suspend, hotplug
and migration of secure software.

Functions are invoked by trapping to the privilege level of the PSCI
firmware (specified as part of the binding below) and passing arguments
in a manner similar to that specified by AAPCS:

	 r0		=> 32-bit Function ID / return value
	{r1 - r3}	=> Parameters

Note that the immediate field of the trapping instruction must be set
to #0.


Main node required properties:

 - compatible    : should contain at least one of:

     * "arm,psci"     : For implementations complying to PSCI versions prior
			to 0.2.
			For these cases function IDs must be provided.

     * "arm,psci-0.2" : For implementations complying to PSCI 0.2.
			Function IDs are not required and should be ignored by
			an OS with PSCI 0.2 support, but are permitted to be
			present for compatibility with existing software when
			"arm,psci" is later in the compatible list.

     * "arm,psci-1.0" : For implementations complying to PSCI 1.0.
			PSCI 1.0 is backward compatible with PSCI 0.2 with
			minor specification updates, as defined in the PSCI
			specification[2].

 - method        : The method of calling the PSCI firmware. Permitted
                   values are:

                   "smc" : SMC #0, with the register assignments specified
		           in this binding.

                   "hvc" : HVC #0, with the register assignments specified
		           in this binding.

Main node optional properties:

 - cpu_suspend   : Function ID for CPU_SUSPEND operation

 - cpu_off       : Function ID for CPU_OFF operation

 - cpu_on        : Function ID for CPU_ON operation

 - migrate       : Function ID for MIGRATE operation

Device tree nodes that require usage of PSCI CPU_SUSPEND function (ie idle
state nodes, as per bindings in [1]) must specify the following properties:

- arm,psci-suspend-param
		Usage: Required for state nodes[1] if the corresponding
                       idle-states node entry-method property is set
                       to "psci".
		Value type: <u32>
		Definition: power_state parameter to pass to the PSCI
			    suspend call.

Example:

Case 1: PSCI v0.1 only.

	psci {
		compatible	= "arm,psci";
		method		= "smc";
		cpu_suspend	= <0x95c10000>;
		cpu_off		= <0x95c10001>;
		cpu_on		= <0x95c10002>;
		migrate		= <0x95c10003>;
	};

Case 2: PSCI v0.2 only

	psci {
		compatible	= "arm,psci-0.2";
		method		= "smc";
	};

Case 3: PSCI v0.2 and PSCI v0.1.

	A DTB may provide IDs for use by kernels without PSCI 0.2 support,
	enabling firmware and hypervisors to support existing and new kernels.
	These IDs will be ignored by kernels with PSCI 0.2 support, which will
	use the standard PSCI 0.2 IDs exclusively.

	psci {
		compatible = "arm,psci-0.2", "arm,psci";
		method = "hvc";

		cpu_on = < arbitrary value >;
		cpu_off = < arbitrary value >;

		...
	};

ARM systems can have multiple cores sometimes in hierarchical arrangement.
This often, but not always, maps directly to the processor power topology of
the system. Individual nodes in a topology have their own specific power states
and can be better represented in DT hierarchically.

For these cases, the definitions of the idle states for the CPUs and the CPU
topology, must conform to the domain idle state specification [3]. The domain
idle states themselves, must be compatible with the defined 'domain-idle-state'
binding [1], and also need to specify the arm,psci-suspend-param property for
each idle state.

DT allows representing CPUs and CPU idle states in two different ways -

The flattened model as given in Example 1, lists CPU's idle states followed by
the domain idle state that the CPUs may choose. Note that the idle states are
all compatible with "arm,idle-state". Additionally, for the domain idle state
the "arm,psci-suspend-param" represents a superset of the CPU's idle state.

Example 2 represents the hierarchical model of CPUs and domain idle states.
CPUs define their domain provider in their psci DT node. The domain controls
the power to the CPU and possibly other h/w blocks that would enter an idle
state along with the CPU. The CPU's idle states may therefore be considered as
the domain's idle states and have the compatible "arm,idle-state". Such domains
may also be embedded within another domain that may represent common h/w blocks
between these CPUs. The idle states of the CPU topology shall be represented as
the domain's idle states. Note that for the domain idle state, the
"arm,psci-suspend-param" represents idle states hierarchically.

In PSCI firmware v1.0, the OS-Initiated mode is introduced. However, the
flattened vs hierarchical DT representation is orthogonal to the OS-Initiated
vs the platform-coordinated PSCI CPU suspend modes, thus should be considered
independent of each other.

The hierarchical representation helps and makes it easy to implement OSI mode
and OS implementations may choose to mandate it. For the default platform-
coordinated mode, both representations are viable options.

Example 1: Flattened representation of CPU and domain idle states
	cpus {
		#address-cells = <1>;
		#size-cells = <0>;

		CPU0: cpu@0 {
			device_type = "cpu";
			compatible = "arm,cortex-a53", "arm,armv8";
			reg = <0x0>;
			enable-method = "psci";
			cpu-idle-states = <&CPU_PWRDN>, <&CLUSTER_RET>,
					  <&CLUSTER_PWRDN>;
		};

		CPU1: cpu@1 {
			device_type = "cpu";
			compatible = "arm,cortex-a57", "arm,armv8";
			reg = <0x100>;
			enable-method = "psci";
			cpu-idle-states = <&CPU_PWRDN>, <&CLUSTER_RET>,
					  <&CLUSTER_PWRDN>;
		};

		idle-states {
			CPU_PWRDN: cpu-power-down {
				compatible = "arm,idle-state";
				arm,psci-suspend-param = <0x0000001>;
				entry-latency-us = <10>;
				exit-latency-us = <10>;
				min-residency-us = <100>;
			};

			CLUSTER_RET: cluster-retention {
				compatible = "arm,idle-state";
				arm,psci-suspend-param = <0x1000011>;
				entry-latency-us = <500>;
				exit-latency-us = <500>;
				min-residency-us = <2000>;
			};

			CLUSTER_PWRDN: cluster-power-down {
				compatible = "arm,idle-state";
				arm,psci-suspend-param = <0x1000031>;
				entry-latency-us = <2000>;
				exit-latency-us = <2000>;
				min-residency-us = <6000>;
			};
	};

	psci {
		compatible = "arm,psci-0.2";
		method = "smc";
	};

Example 2: Hierarchical representation of CPU and domain idle states

	cpus {
		#address-cells = <1>;
		#size-cells = <0>;

		CPU0: cpu@0 {
			device_type = "cpu";
			compatible = "arm,cortex-a53", "arm,armv8";
			reg = <0x0>;
			enable-method = "psci";
			power-domains = <&CPU_PD0>;
			power-domain-names = "psci";
		};

		CPU1: cpu@1 {
			device_type = "cpu";
			compatible = "arm,cortex-a57", "arm,armv8";
			reg = <0x100>;
			enable-method = "psci";
			power-domains = <&CPU_PD1>;
			power-domain-names = "psci";
		};

		idle-states {
			CPU_PWRDN: cpu-power-down {
				compatible = "arm,idle-state";
				arm,psci-suspend-param = <0x0000001>;
				entry-latency-us = <10>;
				exit-latency-us = <10>;
				min-residency-us = <100>;
			};

			CLUSTER_RET: cluster-retention {
				compatible = "domain-idle-state";
				arm,psci-suspend-param = <0x1000010>;
				entry-latency-us = <500>;
				exit-latency-us = <500>;
				min-residency-us = <2000>;
			};

			CLUSTER_PWRDN: cluster-power-down {
				compatible = "domain-idle-state";
				arm,psci-suspend-param = <0x1000030>;
				entry-latency-us = <2000>;
				exit-latency-us = <2000>;
				min-residency-us = <6000>;
			};
		};
	};

	psci {
		compatible = "arm,psci-1.0";
		method = "smc";

		CPU_PD0: cpu-pd0 {
			#power-domain-cells = <0>;
			domain-idle-states = <&CPU_PWRDN>;
			power-domains = <&CLUSTER_PD>;
		};

		CPU_PD1: cpu-pd1 {
			#power-domain-cells = <0>;
			domain-idle-states =  <&CPU_PWRDN>;
			power-domains = <&CLUSTER_PD>;
		};

		CLUSTER_PD: cluster-pd {
			#power-domain-cells = <0>;
			domain-idle-states = <&CLUSTER_RET>, <&CLUSTER_PWRDN>;
		};
	};

[1] Kernel documentation - ARM idle states bindings
    Documentation/devicetree/bindings/arm/idle-states.txt
[2] Power State Coordination Interface (PSCI) specification
    http://infocenter.arm.com/help/topic/com.arm.doc.den0022c/DEN0022C_Power_State_Coordination_Interface.pdf
[3]. PM Domains description
    Documentation/devicetree/bindings/power/power_domain.txt
