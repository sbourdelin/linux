Virtual Display Bridge

This represents a display that is contained within an emulated
environment.

This means that the display engine mainly expects some timing
parameters to be written into it, and after that the emulator will
respond by creating a virtual display with the requested
resolution characteristics.

As the operating system cannot "detect" such a display, rather the
emulator will respond to what the controller outputs, a
chicken-and-egg problem needs to be solved: the resolution and
timing characteristics need to be defined and set up somewhere.

The virtual display bridge solves this by defining a bridge with
all timing characteristics encoded into the device tree node.

Required properies:
- compatible: shall be "virtual-display-bridge"

Required subnodes:
- display-timings: contains in turn a display timing node
  see display-timing.txt
- ports: contains the display ports, see media/video-interfaces.txt

Example:

bridge {
	compatible = "virtual-display-bridge";
	#address-cells = <1>;
	#size-cells = <0>;

	display-timings {
		/* Some standard VGA timing */
		timing0 {
			clock-frequency = <23750>;
			hactive = <640>;
			vactive = <480>;
			hfront-porch = <48>;
			hback-porch = <16>;
			hsync-len = <96>;
			vfront-porch = <33>;
			vback-porch = <9>;
			vsync-len = <3>;
			vrefresh = <60>;
		};
	};

	ports {
		#address-cells = <1>;
		#size-cells = <0>;

		port@0 {
			reg = <0>;

			display_bridge_in: endpoint {
				remote-endpoint = <&foo>;
			};
		};
	};
};
