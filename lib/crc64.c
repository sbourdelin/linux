// SPDX-License-Identifier: GPL-2.0
/*
 * Normal 64bit CRC calculation.
 *
 * This is a basic crc64 implementation following ECMA-182 specification,
 * which can be found from,
 * http://www.ecma-international.org/publications/standards/Ecma-182.htm
 *
 * Dr. Ross N. Williams has a great document to introduce the idea of CRC
 * algorithm, here the CRC64 code is also inspired by the table-driven
 * algorithm and detail example from this paper. This paper can be found
 * from,
 * http://www.ross.net/crc/download/crc_v3.txt
 *
 * crc64table[256] is the lookup table of a table-driver 64bit CRC
 * calculation, which is generated by gen_crc64table.c in kernel build
 * time. The polynomial of crc64 arithmetic is from ECMA-182 specification
 * as well, which is defined as,
 *
 * x^64 + x^62 + x^57 + x^55 + x^54 + x^53 + x^52 + x^47 + x^46 + x^45 +
 * x^40 + x^39 + x^38 + x^37 + x^35 + x^33 + x^32 + x^31 + x^29 + x^27 +
 * x^24 + x^23 + x^22 + x^21 + x^19 + x^17 + x^13 + x^12 + x^10 + x^9 +
 * x^7 + x^4 + x + 1
 *
 * Copyright 2018 SUSE Linux.
 *   Author: Coly Li <colyli@suse.de>
 *
 */

#include <linux/module.h>
#include <linux/types.h>
#include "crc64table.h"

MODULE_DESCRIPTION("CRC64 calculations");
MODULE_LICENSE("GPL v2");

u64 __pure crc64_update(u64 crc, const void *_p, size_t len)
{
	size_t i, t;

	const unsigned char *p = _p;

	for (i = 0; i < len; i++) {
		t = ((crc >> 56) ^ (*p++)) & 0xFF;
		crc = crc64table[t] ^ (crc << 8);
	}

	return crc;
}
EXPORT_SYMBOL_GPL(crc64_update);

u64 __pure crc64(const void *p, size_t len)
{
	u64 crc = 0x0ULL;

	crc = crc64_update(crc, p, len);

	return crc;
}
EXPORT_SYMBOL_GPL(crc64);

/* For checksum calculation in drivers/md/bcache/ */
u64 __pure crc64_bch(const void *p, size_t len)
{
	u64 crc = 0xFFFFFFFFFFFFFFFFULL;

	crc = crc64_update(crc, p, len);

	return (crc ^ 0xFFFFFFFFFFFFFFFFULL);
}
EXPORT_SYMBOL_GPL(crc64_bch);
